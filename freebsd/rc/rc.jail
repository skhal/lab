#!/bin/sh
#
# Copyright 2025 Samvel Khalatyan. All rights reserved.
#
# Manage jail(8) VNET via exec hooks.
#
# Example
#   # file: /etc/jail.conf.d/foo.conf:
#   # A jail with a single network epair.
#   foo {
#     $id = "101";
#     $bridge0 = "bridge0";
#     $bridge0ip = "${bridge0}:10.0.1.${id}/24";
#     vnet;
#     exec.prestart = "/bin/sh /usr/local/etc/rc.jail prestart ${name} ${bridge0}"
#     exec.created  = "/bin/sh /usr/local/etc/rc.jail created ${name} ${bridge0ip}"
#     exec.poststop = "/bin/sh /usr/local/etc/rc.jail poststop ${name} ${bridge0}"
#   }
#   # file: /etc/jail.conf.d/bar.conf:
#   # A jail with two network epairs, each connected to a separate bridge.
#   bar {
#     $id = "101";
#     $bridge0 = "bridge0";
#     $bridge0ip = "${bridge0}:10.0.1.${id}/24";
#     $bridge1 = "bridge1";
#     $bridge1ip = "${bridge0}:10.0.2.${id}/24";
#     vnet;
#     exec.prestart = "/bin/sh /usr/local/etc/rc.jail prestart ${name} ${bridge0} ${bridge1}"
#     exec.created  = "/bin/sh /usr/local/etc/rc.jail created ${name} ${bridge0ip} ${bridge1ip}"
#     exec.poststop = "/bin/sh /usr/local/etc/rc.jail poststop ${name} ${bridge0} ${bridge1}"
#   }
#
# Description
# `rc.jail` manages jail's epair(4) connection to the bridge(4) in the host and
# jailed environments via jail(8) exec-hooks:
#   * exec.prestart: create next logical epair(4) and attach it to the
#     bridge(4).
#   * exec.created: move the jail's side of the epair(4) to the jail(8) and
#     assign it the IP address.
#   * exec.poststop: disconnect jail's epair(4) from the bridge(4) and remove
#     it from the host environment.
#
# `rc.jail` keeps track of the running jail's epair(4) in /var/run/jail/ folder,
# in ${jail_name}.${bridge} file.
#
# vim: ft=sh

# keep-sorted start
readonly CAT_CMD=/bin/cat
readonly IFCONFIG_CMD=/sbin/ifconfig
readonly JEXEC_CMD=/usr/sbin/jexec
readonly MKDIR_CMD=/bin/mkdir
readonly RM_CMD=/bin/rm
# keep-sorted end

readonly JAIL_RUN_PATH=/var/run/jail

# jail_exec_prestart creates an epair(4) for every bridge and connects it to
# that bridge, resultin in N epairs for N bridges.
#
# Arguments:
#   $1 : jail name
#   $* : bridge name
#
# It stores the epair(4) identifier in the jail runtime file for every bridge.
jail_exec_prestart() {
  local jail_name=${1:?'jail_exec_prestart: missing jail name'}

  shift 1
  local jail_bridge jail_epair_a jail_epair jail_epair_descr
  for jail_bridge; do
    jail_epair_a=$(${IFCONFIG_CMD} epair create)
    jail_epair=${jail_epair_a%a}
    jail_write_epair ${jail_name} ${jail_bridge} ${jail_epair}
    jail_epair_descr=jail:${jail_name}:${jail_bridge}
    ${IFCONFIG_CMD} ${jail_epair_a} up descr ${jail_epair_descr}
    ${IFCONFIG_CMD} ${jail_bridge} addm ${jail_epair_a} up
  done
}

# jail_exec_created moves the epair(4) for every bridge to the jail(8) and
# assigns the IP address in the jailed environment. It loads jail's epair(4)
# from the jail runtime file for a given bridge.
#
# Arguments:
#   $1 : jail name
#   $* : colon-separated bridge name and ip
jail_exec_created() {
  local jail_name=${1:?'jail_exec_created: missing jail name'}

  shift 1
  local jail_bridge_and_ip jail_bridge jail_ip jail_epair jail_epair_b jail_epair_descr
  for jail_bridge_and_ip; do
    jail_bridge=${jail_bridge_and_ip%%:*}
    jail_ip=${jail_bridge_and_ip#*:}
    jail_epair="$(jail_read_epair ${jail_name} ${jail_bridge})"
    jail_epair_b=${jail_epair}b
    # Move the b-side of epair(4) inside the jail. All operations on the b-side
    # must run from inside the jail after this completes.
    ${IFCONFIG_CMD} ${jail_epair_b} vnet ${jail_name}
    jail_epair_descr=jail:${jail_name}:${jail_bridge}
    ${JEXEC_CMD} ${jail_name} ${IFCONFIG_CMD} ${jail_epair_b} ${jail_ip} up descr ${jail_epair_descr}
  done
}

# jail_exec_poststop disconnects the epair(4) from corresponding bridge and
# removes the disconnected epair(4) from the host environment.
#
# Arguments:
#   $1 : jail name
#   $* : bridge name
#
# It cleans the jail runtime file for every bridge.
jail_exec_poststop() {
  local jail_name=${1:?'jail_exec_poststop: missing jail name'}

  shift 1
  local jail_bridge jail_epair jail_epair_a
  for jail_bridge; do
    jail_epair=$(jail_read_epair ${jail_name} ${jail_bridge})
    jail_epair_a=${jail_epair}a
    ${IFCONFIG_CMD} ${jail_bridge} deletem ${jail_epair_a}
    ${IFCONFIG_CMD} ${jail_epair_a} destroy
    jail_clean_epair ${jail_name} ${jail_bridge}
  done
}


# jail_write_epair writes the epair(4) identifier to the jail runtime file.
#
# Arguments:
#   $1 : jail name
#   $2 : bridge name
#   $3 : epair
#
# It creates the jail runtime path if one does not exist.
jail_write_epair() {
  local jail_name=${1:?'jail_write_epair: missing jail name'}
  local jail_bridge=${2:?'jail_write_epair: missing jail bridge'}
  local jail_epair=${3:?'jail_write_epair: missing jail epair'}

  local jail_epair_file
  jail_epair_file=$(jail_get_epair_file ${jail_name} ${jail_bridge})
  local jail_epair_file_path=${jail_epair_file%/*}
  if ! [ -d ${jail_epair_file_path} ]; then
    ${MKDIR_CMD} ${jail_epair_file_path}
  fi
  echo ${jail_epair} > ${jail_epair_file}
}

# jail_read_epair reads the epair(4) identifier from the jail runtime file.

# Arguments:
#   $1 : jail name
#   $2 : bridge name
#
# It returns 1 if the jail runtime file does not exist.
jail_read_epair() {
  local jail_name=${1:?'jail_read_epair: missing jail name'}
  local jail_bridge=${2:?'jail_read_epair: missing jail bridge'}

  local jail_epair_file
  jail_epair_file=$(jail_get_epair_file ${jail_name} ${jail_bridge})
  if ! [ -f ${jail_epair_file} ]; then
    echo "jail_read_epair: runtime file ${jail_epair_file} does not exist" >&2
    return 1
  fi
  ${CAT_CMD} ${jail_epair_file}
}

# jail_clean_epair cleans up the jail runtime file.
#
# Arguments:
#   $1 : jail name
#   $2 : bridge name
jail_clean_epair() {
  local jail_name=${1:?'jail_clean_epair: missing jail name'}
  local jail_bridge=${2:?'jail_clean_epair: missing jail bridge'}

  local jail_epair_file=$(jail_get_epair_file ${jail_name} ${jail_bridge})
  if [ -f ${jail_epair_file} ]; then
    ${RM_CMD} ${jail_epair_file}
  fi
}

# jail_get_epair_file builds the jail runtime file name.
#
# Arguments:
#   $1 : jail name
#   $2 : bridge name
#
# The jail runtime file is in JAIL_RUN_PATH.
jail_get_epair_file() {
  local jail_name=${1:?'jail_get_epair_file: missing jail name'}
  local jail_bridge=${2:?'jail_get_epair_file: missing jail bridge'}

  echo ${JAIL_RUN_PATH}/${jail_name}_${jail_bridge}
}

# main runs jail(4) exec hooks.
#
# Arguments:
#   $1 : hook name: prestart, created, poststop
#   $* : hook arguments
#
# It prints an error message on unsupported hooks and return 1.
main() {
  local hook=${1:?'main: missing hook'}
  shift 1

  case ${hook} in
    prestart|created|poststop)
      ;;
    *)
      echo "invalid hook - ${hook}" >&2
      return 1
      ;;
  esac
  local hook_func=jail_exec_${hook}
  ${hook_func} "$@"
}

main "$@"
