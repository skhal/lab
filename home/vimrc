" Copyright 2025 Samvel Khalatyan. All rights reserved.

" -- BASIC
syntax on
set number"

" -- COLORS
set bg=dark
set colorcolumn=80
set cursorline
colorscheme lab

" -- SPACING
set tabstop=2
set softtabstop=2
set shiftwidth=2
set smartindent
set autoindent
set expandtab
au FileType go,make setlocal noexpandtab

" -- SEARCH
set hlsearch
set incsearch

" -- INVISIBLES
set listchars=eol:¬,extends:›,precedes:‹,space:░,tab:«–»,trail:•
nmap <leader>l <esc>:set list!<cr>

" -- SPELL CHECKER
au FileType markdown setlocal spell

filetype plugin on

" -- FORMAT BUFFER.
augroup Format
  au!
  " keep-sorted start
  au FileType bzl setlocal equalprg=buildifier
  au FileType c,cpp setlocal equalprg=clang-format\ -assume-filename=%
  au FileType go setlocal equalprg=goimports
  au FileType markdown setlocal equalprg=markdownfmt
  au FileType pbtxt setlocal equalprg=txtpbfmt
  au FileType sh setlocal equalprg=shfmt\ -i\ 2\ -ci\ -bn
  au FileType yaml setlocal equalprg=yamlfmt\ -in
  " keep-sorted end
  " Format entire buffer `=G` or selection `=` with shortcut `<leader>fc`
  au FileType bzl,c,cpp,go,pbtxt,sh,yaml map <leader>fc gg=G<c-o><c-o>
  au FileType bzl,c,cpp,go,pbtxt,sh,yaml imap <leader>fc <esc>gg=G<c-o><c-o>
augroup END

" -- Plugin github.com:noahfrederick/vim-skeleton
let g:skeleton_replacements = {}
function! g:skeleton_replacements.YEAR()
  let l:year = strftime('%Y')
  echow 'year: ' . l:year
  return l:year
endfunction

" Go
let g:skeleton_replacements_go = {}
function! g:skeleton_replacements_go.PACKAGE()
  let l:package = expand('%:p:h:t')
  echow 'package: ' . l:package
  return l:package
endfunction

let g:skeleton_find_template = {}
function! g:skeleton_find_template.go(path)
  let l:skel = 'skel.go'
  let l:filename = fnamemodify(a:path, ':t')
  if l:filename =~ '_example_test\.go$'
    let l:skel = 'skel_example_test.go'
  elseif l:filename =~ '_test\.go$'
    let l:skel = 'skel_test.go'
  endif
  echow 'skel: ' . l:skel
  return l:skel
endfunction

" C++
function! g:skeleton_find_template.cpp(path)
  let l:filename = 'skel.cc'
  if fnamemodify(a:path, ':t') =~ '_test\.cc$'
    let l:filename = 'skel_test.cc'
  endif
  echow 'skel: ' . l:filename
  return l:filename
endfunction

function! s:skeleton_getGitWorktreeRelpath()
  let l:git_worktree = trim(system('git rev-parse --show-toplevel'))
  let l:path = expand('%:p')
  let l:relpath = fnamemodify(l:path, ':s,^' . l:git_worktree . '/,,')
  return l:relpath
endfunction

function! s:skeleton_getCCNamespace()
  let l:relpath = s:skeleton_getGitWorktreeRelpath()
  let l:namespace = fnamemodify(l:relpath, ':h:gs,/,::,')
  return l:namespace
endfunction

let g:skeleton_replacements_c = {}
function! g:skeleton_replacements_c.NAMESPACE()
  let l:namespace = s:skeleton_getCCNamespace()
  echow 'namespace: ' . l:namespace
  return l:namespace
endfunction

function! g:skeleton_replacements_c.GUARD()
  let l:relpath = s:skeleton_getGitWorktreeRelpath()
  let l:guard = fnamemodify(l:relpath, ':gs,[/.],_,:s,$,_,')
  let l:guard = toupper(l:guard)
  echow 'guard: ' . l:guard
  return l:guard
endfunction

let g:skeleton_replacements_cpp = {}
function! g:skeleton_replacements_cpp.NAMESPACE()
  let l:namespace = s:skeleton_getCCNamespace()
  echow 'namespace: ' . l:namespace
  return l:namespace
endfunction

function! g:skeleton_replacements_cpp.HEADER()
  let l:relpath = s:skeleton_getGitWorktreeRelpath()
  let l:header = fnamemodify(l:relpath, ':s,\(_test\)\?.cc$,.h,')
  echow 'header: ' . l:header
  return escape(l:header, '/')
endfunction

" Protobuf
let g:skeleton_replacements_proto = {}
function! g:skeleton_replacements_proto.PACKAGE()
  " Assuming a .proto is in a folder `foo/bar/pb`, the package is `foo/bar`.
  let l:relpath = s:skeleton_getGitWorktreeRelpath()
  let l:package = fnamemodify(l:relpath, ':h:gs,/,.,')
  let l:package = fnamemodify(l:package, ':s,.pb$,,')
  echow 'package: ' . l:package
  return l:package
endfunction

function! g:skeleton_replacements_proto.GO_PACKAGE()
  let l:go_module = trim(system('go list -m'))
  let l:relpath = s:skeleton_getGitWorktreeRelpath()
  let l:relpath = fnamemodify(l:relpath, ':h')
  let l:go_package = l:go_module . '/' . l:relpath
  echow 'go_package: ' . l:go_package
  return escape(l:go_package, '/')
endfunction

" -- Plugin https://github.com/preservim/tagbar
let g:tagbar_ctags_bin = '/usr/local/bin/uctags'
let g:go_gotags_bin = '/home/skhalatyan/go/bin/gotags'
let g:tagbar_type_go = {
	\ 'ctagstype' : 'go',
	\ 'kinds'     : [
		\ 'p:package',
		\ 'i:imports:1',
		\ 'c:constants',
		\ 'v:variables',
		\ 't:types',
		\ 'n:interfaces',
		\ 'w:fields',
		\ 'e:embedded',
		\ 'm:methods',
		\ 'r:constructor',
		\ 'f:functions'
	\ ],
	\ 'sro' : '.',
	\ 'kind2scope' : {
		\ 't' : 'ctype',
		\ 'n' : 'ntype'
	\ },
	\ 'scope2kind' : {
		\ 'ctype' : 't',
		\ 'ntype' : 'n'
	\ },
	\ 'ctagsbin'  : 'gotags',
	\ 'ctagsargs' : '-sort -silent'
\ }
nmap <leader>o :TagbarToggle<CR>

" -- Plugin https://github.com/prabirshrestha/vim-lsp
" keep-sorted start
let g:lsp_diagnostics_echo_cursor = 1
let g:lsp_diagnostics_virtual_text_enabled = 0
let g:lsp_log_file = expand('~/.log/vim-lsp.log')
let g:lsp_log_verbose = 0
let g:lsp_use_native_client = 1
" keep-sorted end

" Gopls https://go.dev/gopls/editor/vim#a-hrefvimlsp-idvimlspvim-lspa
augroup LspGo
  au!
  autocmd User lsp_setup call lsp#register_server({
      \ 'name': 'gopls',
      \ 'cmd': {server_info->['gopls']},
      \ 'whitelist': ['go'],
      \ })
  autocmd FileType go setlocal omnifunc=lsp#complete
  autocmd FileType go nmap <buffer> gchi <plug>(lsp-call-hierarchy-incoming)
  autocmd FileType go nmap <buffer> gcho <plug>(lsp-call-hierarchy-outgoing)
  autocmd FileType go nmap <buffer> gca <plug>(lsp-code-action)
  autocmd FileType go nmap <buffer> gcaf <plug>(lsp-code-action-float)
  autocmd FileType go nmap <buffer> gcap <plug>(lsp-code-action-preview)
  autocmd FileType go nmap <buffer> gcl <plug>(lsp-code-lens)
  autocmd FileType go nmap <buffer> gd <plug>(lsp-declaration)
  autocmd FileType go nmap <buffer> gpd <plug>(lsp-peek-declaration)
  autocmd FileType go nmap <buffer> gd <plug>(lsp-definition)
  autocmd FileType go nmap <buffer> gpd <plug>(lsp-peek-definition)
  autocmd FileType go nmap <buffer> gds <plug>(lsp-document-symbol)
  autocmd FileType go nmap <buffer> gdss <plug>(lsp-document-symbol-search)
  autocmd FileType go nmap <buffer> gdd <plug>(lsp-document-diagnostics)
  autocmd FileType go nmap <buffer> gh <plug>(lsp-hover)
  autocmd FileType go nmap <buffer> ghf <plug>(lsp-hover-float)
  autocmd FileType go nmap <buffer> ghp <plug>(lsp-hover-preview)
  autocmd FileType go nmap <buffer> gpc <plug>(lsp-preview-close)
  autocmd FileType go nmap <buffer> gpf <plug>(lsp-preview-focus)
  autocmd FileType go nmap <buffer> gne <plug>(lsp-next-error)
  autocmd FileType go nmap <buffer> gnenw <plug>(lsp-next-error-nowrap)
  autocmd FileType go nmap <buffer> gpe <plug>(lsp-previous-error)
  autocmd FileType go nmap <buffer> gpenw <plug>(lsp-previous-error-nowrap)
  autocmd FileType go nmap <buffer> gnw <plug>(lsp-next-warning)
  autocmd FileType go nmap <buffer> gnwnw <plug>(lsp-next-warning-nowrap)
  autocmd FileType go nmap <buffer> gpw <plug>(lsp-previous-warning)
  autocmd FileType go nmap <buffer> gpwnw <plug>(lsp-previous-warning-nowrap)
  autocmd FileType go nmap <buffer> gnd <plug>(lsp-next-diagnostic)
  autocmd FileType go nmap <buffer> gndnw <plug>(lsp-next-diagnostic-nowrap)
  autocmd FileType go nmap <buffer> gpd <plug>(lsp-previous-diagnostic)
  autocmd FileType go nmap <buffer> gpdnw <plug>(lsp-previous-diagnostic-nowrap)
  autocmd FileType go nmap <buffer> gr <plug>(lsp-reference)
  autocmd FileType go nmap <buffer> gr <plug>(lsp-rename)
  autocmd FileType go nmap <buffer> gtd <plug>(lsp-type-definition)
  autocmd FileType go nmap <buffer> gth <plug>(lsp-type-hierarchy)
  autocmd FileType go nmap <buffer> gptd <plug>(lsp-peek-type-definition)
  autocmd FileType go nmap <buffer> gws <plug>(lsp-workspace-symbol)
  autocmd FileType go nmap <buffer> gwss <plug>(lsp-workspace-symbol-search)
  autocmd FileType go nmap <buffer> gdf <plug>(lsp-document-format)
  autocmd FileType go nmap <buffer> gdrf <plug>(lsp-document-range-format)
  autocmd FileType go nmap <buffer> gi <plug>(lsp-implementation)
  autocmd FileType go nmap <buffer> gpi <plug>(lsp-peek-implementation)
  autocmd FileType go nmap <buffer> gs <plug>(lsp-status)
  autocmd FileType go nmap <buffer> gnr <plug>(lsp-next-reference)
  autocmd FileType go nmap <buffer> gpr <plug>(lsp-previous-reference)
  autocmd FileType go nmap <buffer> gsh <plug>(lsp-signature-help)
augroup END

augroup LspCpp
  au!
  autocmd User lsp_setup call lsp#register_server({
      \ 'name': 'clangd',
      \ 'cmd': {server_info->['clangd']},
      \ 'whitelist': ['c', 'cpp'],
      \ })
  autocmd FileType c,cpp setlocal omnifunc=lsp#complete
  autocmd FileType c,cpp nmap <buffer> gchi <plug>(lsp-call-hierarchy-incoming)
  autocmd FileType c,cpp nmap <buffer> gcho <plug>(lsp-call-hierarchy-outgoing)
  autocmd FileType c,cpp nmap <buffer> gca <plug>(lsp-code-action)
  autocmd FileType c,cpp nmap <buffer> gcaf <plug>(lsp-code-action-float)
  autocmd FileType c,cpp nmap <buffer> gcap <plug>(lsp-code-action-preview)
  autocmd FileType c,cpp nmap <buffer> gcl <plug>(lsp-code-lens)
  autocmd FileType c,cpp nmap <buffer> gd <plug>(lsp-declaration)
  autocmd FileType c,cpp nmap <buffer> gpd <plug>(lsp-peek-declaration)
  autocmd FileType c,cpp nmap <buffer> gd <plug>(lsp-definition)
  autocmd FileType c,cpp nmap <buffer> gpd <plug>(lsp-peek-definition)
  autocmd FileType c,cpp nmap <buffer> gds <plug>(lsp-document-symbol)
  autocmd FileType c,cpp nmap <buffer> gdss <plug>(lsp-document-symbol-search)
  autocmd FileType c,cpp nmap <buffer> gdd <plug>(lsp-document-diagnostics)
  autocmd FileType c,cpp nmap <buffer> gh <plug>(lsp-hover)
  autocmd FileType c,cpp nmap <buffer> ghf <plug>(lsp-hover-float)
  autocmd FileType c,cpp nmap <buffer> ghp <plug>(lsp-hover-preview)
  autocmd FileType c,cpp nmap <buffer> gpc <plug>(lsp-preview-close)
  autocmd FileType c,cpp nmap <buffer> gpf <plug>(lsp-preview-focus)
  autocmd FileType c,cpp nmap <buffer> gne <plug>(lsp-next-error)
  autocmd FileType c,cpp nmap <buffer> gnenw <plug>(lsp-next-error-nowrap)
  autocmd FileType c,cpp nmap <buffer> gpe <plug>(lsp-previous-error)
  autocmd FileType c,cpp nmap <buffer> gpenw <plug>(lsp-previous-error-nowrap)
  autocmd FileType c,cpp nmap <buffer> gnw <plug>(lsp-next-warning)
  autocmd FileType c,cpp nmap <buffer> gnwnw <plug>(lsp-next-warning-nowrap)
  autocmd FileType c,cpp nmap <buffer> gpw <plug>(lsp-previous-warning)
  autocmd FileType c,cpp nmap <buffer> gpwnw <plug>(lsp-previous-warning-nowrap)
  autocmd FileType c,cpp nmap <buffer> gnd <plug>(lsp-next-diagnostic)
  autocmd FileType c,cpp nmap <buffer> gndnw <plug>(lsp-next-diagnostic-nowrap)
  autocmd FileType c,cpp nmap <buffer> gpd <plug>(lsp-previous-diagnostic)
  autocmd FileType c,cpp nmap <buffer> gpdnw <plug>(lsp-previous-diagnostic-nowrap)
  autocmd FileType c,cpp nmap <buffer> gr <plug>(lsp-reference)
  autocmd FileType c,cpp nmap <buffer> gr <plug>(lsp-rename)
  autocmd FileType c,cpp nmap <buffer> gtd <plug>(lsp-type-definition)
  autocmd FileType c,cpp nmap <buffer> gth <plug>(lsp-type-hierarchy)
  autocmd FileType c,cpp nmap <buffer> gptd <plug>(lsp-peek-type-definition)
  autocmd FileType c,cpp nmap <buffer> gws <plug>(lsp-workspace-symbol)
  autocmd FileType c,cpp nmap <buffer> gwss <plug>(lsp-workspace-symbol-search)
  autocmd FileType c,cpp nmap <buffer> gdf <plug>(lsp-document-format)
  autocmd FileType c,cpp nmap <buffer> gdrf <plug>(lsp-document-range-format)
  autocmd FileType c,cpp nmap <buffer> gi <plug>(lsp-implementation)
  autocmd FileType c,cpp nmap <buffer> gpi <plug>(lsp-peek-implementation)
  autocmd FileType c,cpp nmap <buffer> gs <plug>(lsp-status)
  autocmd FileType c,cpp nmap <buffer> gnr <plug>(lsp-next-reference)
  autocmd FileType c,cpp nmap <buffer> gpr <plug>(lsp-previous-reference)
  autocmd FileType c,cpp nmap <buffer> gsh <plug>(lsp-signature-help)
augroup END

" -- Plugin https://github.com/prabirshrestha/asyncomplete.vim
let g:asyncomplete_log_file = expand('~/.log/asyncomplete.log')

inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
inoremap <expr> <cr>    pumvisible() ? asyncomplete#close_popup() : "\<cr>"

" Trigger pop up on demand
let g:asyncomplete_auto_popup = 0

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1] =~ '\s'
endfunction

inoremap <silent><expr> <Tab>
  \ pumvisible() ? "\<C-n>" :
  \ <SID>check_back_space() ? "\<TAB>" :
  \ asyncomplete#force_refresh()
inoremap <expr><S-Tab> pumvisible() ? "\<C-p>" : "\<C-h>"

" -- Keyword https://vi.stackexchange.com/questions/6228/how-can-i-get-vim-to-show-documentation-of-a-c-c-function
augroup Keyword
  au!
  autocmd FileType c,cpp setlocal keywordprg=cppman
  autocmd FileType go    setlocal keywordprg=:GoDoc
augroup END
